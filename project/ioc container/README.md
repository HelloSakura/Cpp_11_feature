Inversion of Control： 控制反转

1、思想：对象之间的关系在外面组装，外面可以根据需求灵活地配置这种机制的对象创建策略，从而获得想要的目标对象。应用本身不负责对象的创建和维护，而交给一个外部容器来负责。

2、依赖注入（Dependency Injection）：将对象创建的依赖关系注入到目标类型的构造函数中。
    一种方法是通过map保存对象的名字，以及相应的构造函数，对外提供注册和构造接口，通过对象名来寻找。


3、类型擦除
（1）通过多态来擦除类型：将派生类型隐式转换成基类型，通过基类调用虚函数。可以做到部分类型擦除
（2）通过模板来擦除类型：将不同类型的共同行为进行抽象，不同类型之间不需要通过继承这种强耦合这种方式去获得共同的行为。
（3）通过Any和闭包来擦除类型，使用lambda表达式来创建闭包，可以隐藏具体的类型，闭包的类型是定的，但是闭包中的内容就不是固定的（一般来说内部是一个构造函数，闭包返回构造出的对象）；而Any类能够代表任何类型，在需要的时候通过cast即可转换到合适的类型


4、关于variant：能代表定义的多种类，允许赋不同的类型值给variant，可以用于擦除类型；但就variant实现的一方面，尤其是在type_index的使用，和placement new分配对齐内存空间上还有很多的问题
     IOC容器，现在看来并没有多么的神奇。主要的就是类型擦除和以及泛型编程（根据条件进行编译以及一些编程技巧）。而对象的依赖关系，通过map中key与value中的一对一的关系来确定，key可以使用对象的名字，而value则是通过Any来隐藏类型，需要使用的时候通过AnyCast转换成合适的类型即可。



