1、为啥：对象之间的关系一般有：依赖、关联、聚合、组合和继承，而大规模的软件开发过程中，对象之间的关系十分复杂，

2、消息总线：
       关于消息总线的设计，在设计的地方碰到了几个问题，第一个问题便是如何进行通用消息的定义以及如何将各种可调用对象装换成通用消息，通过map一对一的关系可以完成消息和函数之间的映射，同时使用Any将不同类型的可调用对象进行类型擦除。必要的时候进行cast转换。
      首先需要解决的是，如何将可调用对象（几种）转换成统一的格式，消息总线的注册接口可接收所有语义的对象，所以将消息定义成统一的格式std::function<R (Args…)>
①通用消息：泛型函数在一定程度上可以解决这个问题，一般的格式为：主题+泛型函数的签名
（topic + std::function<R (Args…)>）
②转换过程中的一些问题： 完成转换之后的另一个问题是，在发送消息的时候，如何保证只有注册了特定主题和消息的接受者对象才能接收到分发的消息，很简单的通过multimap就可以完成一对多的映射。（注册的是函数类型名 + 主题名， 对应的是封装好的可调用对象）

	关于实现上的一些细节：
       通过模板函数参数的自动推导推导出参数类型，通过参数类型进行模板实例化，使用实例化中的信息。
写法是真的骚，通过函数模版的自动推导参数类型的功能推导出函数类型，然后用函数类型特例化结构模板，通过结构模板来完成类型分离，如返回值类型，参数类型


4、形成步骤：
（1）将各种可调用对象转换成统一的形式
（2）保存注册的消息：并不是把消息发送到所有的接受者，而是只有符合某个主题的对象才接受到消息
（3）发消息，一般来说会有一个全局的Bus，各个对象通过它来发送消息。

     总线解决了一个问题是，极大的降低了各个对象之间的组合关系，主要降低的就是组合关系，原来几个对象之间的要想通知，或者完成消息传递到另一个对象，往往是持有对象的一个句柄，然后通过句柄的方式来完成传递，像观察者和中介者模式，主要就是采用这种方式，只不过前者是通过多个对象注册而后者则是预先要知道消息的转发方式（而且适用范围一般指限于一个实例的情况），而总线则实现对各种主题进行广播的形式（重点是广播），复杂度耦合度降得很爽。

❤我觉得吧：宏加模板还是很牛掰的，不过对于const和保持move和forward语义，有些眉目了。
